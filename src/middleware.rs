use poem::{
    handler, web::Data, Endpoint, EndpointExt, Middleware, Request, Result,
};

use super::json_web_token::decode;


pub fn test_decode() -> () {
    if let Ok(decoded) = decode("test") {
        let header = decoded.0.header;
        let payload = decoded.0.payload;
        let signature = decoded.1;
    }
}
/// A middleware that extract token from HTTP headers.
struct TokenMiddleware;

impl<E: Endpoint> Middleware<E> for TokenMiddleware {
    type Output = TokenMiddlewareImpl<E>;

    fn transform(&self, ep: E) -> Self::Output {
        TokenMiddlewareImpl { ep }
    }
}

/// The new endpoint type generated by the TokenMiddleware.
struct TokenMiddlewareImpl<E> {
    ep: E,
}

const TOKEN_HEADER: &str = "Authorization";

/// Token data
struct Token(String);

#[poem::async_trait]
impl<E: Endpoint> Endpoint for TokenMiddlewareImpl<E> {
    type Output = E::Output;

    async fn call(&self, mut req: Request) -> Result<Self::Output> {
        if let Some(value) = req
            .headers()
            .get(TOKEN_HEADER)
            .and_then(|value| value.to_str().ok())
        {
            // Insert token data to extensions of request.
            let token = value.to_string();
            req.extensions_mut().insert(Token(token));
        }

        // call the next endpoint.
        self.ep.call(req).await
    }
}

#[handler]
async fn index(Data(token): Data<&Token>) -> String {
    token.0.clone()
}

// Use the `TokenMiddleware` middleware to convert the `index` endpoint.
// let ep = index.with(TokenMiddleware);
// 
// let mut resp = TestClient::new(ep)
//     .get("/")
//     .header(TOKEN_HEADER, "abc")
//     .send()
//     .await;
// resp.assert_status_is_ok();
// resp.assert_text("abc").await;

/*
use anyhow;
use oauth2::{
    AuthorizationCode,
    AuthUrl,
    ClientId,
    ClientSecret,
    CsrfToken,
    PkceCodeChallenge,
    RedirectUrl,
    Scope,
    TokenResponse,
    TokenUrl
};
use oauth2::basic::BasicClient;
use oauth2::reqwest::async_http_client;
use url::Url;

// Create an OAuth2 client by specifying the client ID, client secret, authorization URL and
// token URL.
let client =
    BasicClient::new(
        ClientId::new("client_id".to_string()),
        Some(ClientSecret::new("client_secret".to_string())),
        AuthUrl::new("http://authorize".to_string())?,
        Some(TokenUrl::new("http://token".to_string())?)
    )
    // Set the URL the user will be redirected to after the authorization process.
    .set_redirect_uri(RedirectUrl::new("http://redirect".to_string())?);

// Generate a PKCE challenge.
let (pkce_challenge, pkce_verifier) = PkceCodeChallenge::new_random_sha256();

// Generate the full authorization URL.
let (auth_url, csrf_token) = client
    .authorize_url(CsrfToken::new_random)
    // Set the desired scopes.
    .add_scope(Scope::new("read".to_string()))
    .add_scope(Scope::new("write".to_string()))
    // Set the PKCE code challenge.
    .set_pkce_challenge(pkce_challenge)
    .url();

// This is the URL you should redirect the user to, in order to trigger the authorization
// process.
println!("Browse to: {}", auth_url);

// Once the user has been redirected to the redirect URL, you'll have access to the
// authorization code. For security reasons, your code should verify that the `state`
// parameter returned by the server matches `csrf_state`.

// Now you can trade it for an access token.
let token_result = client
    .exchange_code(AuthorizationCode::new("some authorization code".to_string()))
    // Set the PKCE code verifier.
    .set_pkce_verifier(pkce_verifier)
    .request_async(async_http_client)
    .await?;

// Unwrapping token_result will either produce a Token or a RequestTokenError.

*/
/*
import { RequestHandler } from "express";
import passport from "passport";
import { BearerStrategy } from "passport-azure-ad";
import { MockStrategy } from "passport-mock-strategy";
import { env } from "./env.mjs";

export function auth(): RequestHandler {
  passport.initialize();
  passport.use(
    env.NODE_ENV === "test"
      ? new MockStrategy({ name: "my-mock-strategy" })
      : new BearerStrategy(
          {
            identityMetadata: `https://login.microsoftonline.com/${env.SAMLA_AZURE_AD_TENANT_ID}/v2.0/.well-known/openid-configuration`,
            clientID: env.SAMLA_AZURE_AD_CLIENT_ID,
            issuer: `https://login.microsoftonline.com/${env.SAMLA_AZURE_AD_TENANT_ID}/v2.0`,
            validateIssuer: true,
            passReqToCallback: true,
            allowMultiAudiencesInToken: false,
            loggingNoPII: false,
            scope: ["api-access"],
          },
          (_req, token, done) => {
            done(null, {}, token);
          }
        )
  );

  return passport.authenticate("oauth-bearer", {
    session: false,
    failWithError: false,
  });
}

*/